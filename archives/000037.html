<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>Curiosity is bliss: The dark side of C# Delegates</title>

<link rel="stylesheet" href="http://blog.monstuff.com/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.monstuff.com/index.rdf" />

<link rel="start" href="http://blog.monstuff.com/" title="Home" />
<link rel="prev" href="http://blog.monstuff.com/archives/000036.html" title="Mechanical chain reaction Ad" />

<link rel="next" href="http://blog.monstuff.com/archives/000038.html" title="C# Delegates strike back" />



<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-74363-1";
urchinTracker();
</script>

<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'blog.monstuff.com';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>



<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="http://blog.monstuff.com/archives/000037.html">
<dc:title>The dark side of C# Delegates</dc:title>
<dc:description>This article assumes basic programming experience with delegates. Delegates are a .NET framework feature that allows for type-safe function pointers. Actually, they are a bit more than function pointers, because they are object oriented, as their second name -bound method references- expresses. It means that the method pointer stored in the delegate may actually be bound to an instance of a specific object: when the delegate is invoked, the method is called on that target object. In the code of that method, you can notice that the this variable refers to that same target object. But as we&apos;ll also see,...</dc:description>
<dc:creator>Julien</dc:creator>
<dc:date>2003-04-18T15:23:36-08:00</dc:date>
<license rdf:resource="http://creativecommons.org/licenses/by-sa/1.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-sa/1.0/">
<requires rdf:resource="http://web.resource.org/cc/Attribution" />
<requires rdf:resource="http://web.resource.org/cc/Notice" />
<requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
<permits rdf:resource="http://web.resource.org/cc/Reproduction" />
<permits rdf:resource="http://web.resource.org/cc/Distribution" />
<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
</License>
</rdf:RDF>
-->



</head>

<body>

<div id="banner">
<h1><a href="http://blog.monstuff.com/" accesskey="1">Curiosity is bliss</a></h1>
<span class="description">Julien Couvreur's programming blog and more</span>
</div>

<div id="container">

<div class="blog">







<div id="menu">
<a href="http://blog.monstuff.com/archives/000036.html">« Mechanical chain reaction Ad</a>&nbsp;&nbsp; 

| &nbsp;&nbsp;<a href="/archives.html">Archive list</a>&nbsp;&nbsp;
| &nbsp;&nbsp;<a href="http://blog.monstuff.com/archives/000380.html">Thick displays</a> (latest)

</div>

</div>

<div class="blog">

<!-- <h2 class="date">April 18, 2003</h2> -->




<div class="blogbody">
<!-- google_ad_section_start -->

<h2 class="title">The dark side of C# Delegates</h2>

<p>This article assumes basic programming experience with delegates.</p>

<p>Delegates are a .NET framework feature that allows for type-safe function pointers. Actually, they are a bit more than function pointers, because they are object oriented, as their second name -<i>bound method references</i>- expresses. It means that the method pointer stored in the delegate may actually be bound to an instance of a specific object: when the delegate is invoked, the method is called on that target object. In the code of that method, you can notice that the <i>this</i> variable refers to that same target object.<br />
But as we'll also see, delegates aren't always bound to an object. They support storing a static method pointer, which isn't bound to any specific instance of the class, like classic C-style function pointers.</p>

<p>In this article, we'll dig into delegates, their specificities, some of their inner workings and the role of the compiler in their implementation.<br />
Note: We won't consider the singlecast vs. multicast aspect of delegates.</p>

<p><u>Update:</u> a follow-up on this article can be found on this <a href="http://blog.monstuff.com/archives/000038.html#more">C# Delegates strike back</a> entry.<br />
<u>Update:</u> I wrote another follow-up on this article, about <a href="http://blog.monstuff.com/archives/000040.html">C# events vs. delegates</a></p>

<a name="more"></a>
<p><b>Syntax reminder</b><br />
Here is a little sample of code using delegates:<br />
<div class="code">// Declare<br />
public delegate void StringLogging(string msg);</p>

<p>class Class1<br />
{<br />
&nbsp;	StringLogging stringHandler;</p>

<p>&nbsp;	static void Main(string[] args)<br />
&nbsp;	{<br />
&nbsp;&nbsp;		Class1 logger = new Class1();</p>

<p>&nbsp;&nbsp;		// Instanciate with static binding<br />
&nbsp;&nbsp;		logger.stringHandler = new StringLogging(Class1.StringOutput);<br />
&nbsp;&nbsp;		// Instanciate with instance binding<br />
&nbsp;&nbsp;		logger.stringHandler = new StringLogging(logger.StringDrop);</p>

<p>&nbsp;&nbsp;		// Invoke<br />
&nbsp;&nbsp;		logger.stringHandler("hello");<br />
&nbsp;	}</p>

<p>&nbsp;	// Outputs strings to the console<br />
&nbsp;	public static void StringOutput(string msg) <br />
&nbsp;	{<br />
&nbsp;&nbsp;		Console.WriteLine(msg);<br />
&nbsp;	}</p>

<p>&nbsp;	// Drops strings into a blackhole<br />
&nbsp;	public void StringDrop(string msg)<br />
&nbsp;	{<br />
&nbsp;&nbsp;		return;<br />
&nbsp;	}<br />
}</div></p>

<p><b>Delegates vs. Java Listeners</b><br />
Delegates are a pretty interesting construct, although somewhat "magical". They allow easy binding of event handlers and other callback mechanisms, without the use of a separate class implementing a specific listener interface (which is the Java approach for callbacks).<br />
<a href="http://archive.devx.com/upload/free/features/javapro/1998/jp_junjul_98/lo0698/loside2.htm">This page</a> details the comparison between delegates and the classic Command design pattern.<br />
Basically, instead passing a callback function via an object of known interface that both communicating parties agree on, delegates only need the two parties to use the same function signature. This function signature contract is set during the declaration of a delegate.</p>

<p>For example, in the <i>public delegate void MouseClickDelegate(int buttonClicked)</i> delegate declaration, the interface for the callback function is <i>void foo(int)</i>.</p>

<p>This delegate declaration is actually transformed by the compiler into a class <i>MouseClickDelegate</i> that can only be created by binding it to a <i>void foo(int)</i> method and only be invoked following that same interface <i>void Invoke(int)</i>. Both of these constraints are verified by the compiler at compile time.<br />
You can run <i>ildasm</i> on an assembly containing a delegate definition, and check out the generated delegate class and its interface (notice the <i>Invoke</i> method). You can also see that this class inherits from <i>System.MulticastDelegate</i> and therefore indirectly from <i>System.Delegate</i> (we'll look at this some more further down).</p>

<p>So, delegates are actually implemented using objects, albeit special ones. This is nicely introduced on this "<a href="http://www.ondotnet.com/pub/a/dotnet/2002/11/04/delegates.htm">Understanding the Nuances of Delegates in C#</a>" page at O'Reilly Network. In particular, delegates are declared in a way similar to other objects (inside a namespace or inside another object) and can be instantiated and passed around like other typed variables.<br />
Unfortunately, reading this article only left me with more curiousity about delegates and their implementations. That's because the article doesn't explain how delegate classes are generated by the compiler (see example above), but also because it doesn't say how those method pointers are bound to the object holding the method.</p>

<p><br />
<b>Object bound</b><br />
Trying to figure out how delegates where not just function pointers, but actual method calls on an object, I dug up the <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemdelegateclasstopic.asp">System.Delegate class reference</a> at MSDN.<br />
The <i>System.Delegate</i> class has two interesting properties: <i>Target</i> (of type <i>object</i>) and <i>Method</i> (of type <i>MethodInfo</i>). <i>Target</i> references the object that the method is actually bound to. So, each delegate object is really a wrapper around a method and an object to be operated on when the method is called.</p>

<p>In the previous <i>MouseClickDelegate</i> delegate example, the dis-assembling of the assembly reveals the generated <i>MouseClickDelegate</i> class, with the detail of its attributes and methods. One of these methods is the following constructor (which is the same for all delegate objects): <i>.ctor : void(object, native int)</i>.<br />
This means that when you instanciate this class with <i>new MouseClickDelegate(this.MyMouseClickListeningMethod)</i>, the compiler will actually replace this instanciation with a <i>new MouseClickDelegate(this, ...)</i>. This is how the the delegate gets bound to the object.</p>

<p>When the delegate is instanciated with a static method, the <i>object</i> parameter in the constructor is <i>null</i> and the created delegate object has a <i>null</i> <i>Target</i>.<br />
The assembly for such a static method delegates shows:<br />
<div class="code">IL_000d: ldnull<br />
IL_000e: ldftn void MyDelegateNamespace.Class1::StaticMethod(int32)<br />
IL_0014: newobj instance void MyDelegateNamespace.MouseClickDelegate::.ctor(object,<br />
                                                                   native int)</div></p>

<p>So we can see that in such an instantiation, there is no instance object (it's null), as the method is static.</p>

<p><br />
<b>Reflection!?</b><br />
We have seen that in the <i>System.Delegate</i> class, the <i>Target</i> references the object to which the method pointer is bound, but about the <i>Method</i>?<br />
The <i>Method</i> property is a <i>MethodInfo</i> (part of the <i>System.Reflection</i> namespace). Also MSDN describes this property with: "Gets the method represented by the delegate". Does that mean every delegate invocation goes through Reflection?!<br />
Although I don't have much knowledge on the Reflection component of the framework, I would expect such an implementation to have performance problems.</p>

<p>Looking at the dis-assembled MSIL code, we see that the invocation of the delegate looks like:<br />
<div class="code">IL_0033: callvirt instance string MyDelegateNamespace.MouseClickDelegate::Invoke(int32)</div></p>

<p>The compiler recognized the "function call" on the delegate and replaced it with a call to the delegates <i>Invoke</i> compiler-generated method. The compiler also blocks any explicit call <i>Invoke</i> from your code, by issuing an error: "Invoke cannot be called directly on a delegate".<br />
Unfortunately, this doesn't reveal whether the <i>Invoke</i> method relies on reflection to implement the invocation or if it relies on a native CLR method call mechanism.</p>

<p>The MSIL code for the delegate's <i>Invoke</i> method doesn't bring any information either:<br />
<div class="code">.method public hidebysig virtual instance void <br />
 Invoke(int32 i) runtime managed<br />
 {<br />
 } // end of method MouseClickDelegate::Invoke</div></p>

<p>The "runtime managed" seems to indicate that the runtime is responsible for the implementation of this method. I haven't found how this works yet.</p>

<p>The only clues that I have gathered on the invocation mechanism are the signature of the delegate constructor (what is the second parameter in <i>.ctor void(object, native int)</i> ?) and a rather detailled explanation of the role of the compiler in the delegates' implementation <a href="http://msdn.microsoft.com/msdnmag/issues/01/04/net/default.aspx">in this delegates article in MSDNmag</a>.<br />
It appears that the second argument of the delegate constructor is a reference to the method, via "a special Int32 value (obtained from a MethodDef or MethodRef metadata token) that identifies the method is passed for the methodPtr parameter".<br />
Unluckily, MethodDef and MethodRef don't seem to be well publicly documented as they don't bring much information on MSDN (they are mentioned <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfSystemReflectionEmitOpCodesClassNewobjTopic.asp">here</a>on MSDN) or Google...</p>

<p><u>Update:</u> I know understand what these token mean. For more info read my series on <a href="http://blog.monstuff.com/archives/000058.html">Runtime IL modification</a>.</p>

<p><b>Summary</b><br />
I am going to investigate the mono:: compiler source code to try and find the missing details about the implementation of the <i>Invoke</i> method and the meaning of the <i>native int</i> that references the method. But we have seen that the compiler plays a major role in making the delegates work.<br />
Encountering a delegate declaration, the compiler actually generates a class with an <i>Invoke</i> method that matches the delegate declaration's signature.<br />
Then, when a delegate instanciation is compiled, it gets verified (type-wise) and replaced by a call to the delegate constructor passing in an object and a method reference (via an int).<br />
And last, the compiler recognizes delegates invocations and compiles them as call on the <i>Invoke</i> method.</p>

<p><br />
Cheers,<br />
Dumky</p>

<p><br />
<b>References</b><br />
<a href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvj/html/msdn_deltruth.asp">Microsoft on delegates and comparison with Inner classes</a>, is a response to Sun's criticism of delegates.</p>

<p><a href="http://cvs.hispalinux.es/cgi-bin/cvsweb/mcs/class/corlib/System/Delegate.cs?rev=1.24&content-type=text/x-cvsweb-markup&cvsroot=mono">Mono:: implementation of the Delegate class</a></p>

<p><a href="http://www.123aspx.com/rotor/rotorsrc.aspx?rot=40576">Rotor implementation for the Delegate class</a></p>

<p><a href="http://www.123aspx.com/rotor/default.aspx">Rotor source code online</a></p>

<p><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconcompilersupplieddelegatebegininvokeendinvokemethods.asp">Compiler-supplied delegate methods</a> at MSDN: Invoke, BeginInvoke and EndInvoke.</p>

<p><a href="http://www.geocities.com/csharpfaq/delegates.html">Method signature matching isn't complete type-safety</a></p>

<p><a href="http://www.jelovic.com/weblog/e133.htm">Interface-style vs. delegate-style performance</a></p>

<span class="posted">Posted by Julien on April 18, 2003. <a href="http://blog.monstuff.com/archives/000037.html" rel="bookmark">Permalink</a> <!-- -->
<br /></span>

</div>



<div class="comments-head"><a name="comments"></a>Comments</div>

<div class="comments-body">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'curiosityisbliss'; 
        var disqus_identifier = '37';
        var disqus_url = 'http://blog.monstuff.com/archives/000037.html';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>    





<div class="comments-body">
<p>O'Reilly Network just added an article related to delegates, and how they compare to similar Java patterns.<br />
	<br />
A Java Programmer Looks at C# Delegates: <a href="http://www.onjava.com/pub/a/onjava/2003/05/21/delegates.html">http://www.onjava.com/pub/a/onjava/2003/05/21/delegates.html</a></p>
<span class="comments-post">Posted by: <a href="mailto&#58;dumky&#64;privateemail&#46;email">Dumky</a> at May 23, 2003 11:18 AM</span>
</div>
<div class="comments-body">
<p>Hi,</p>

<p>Your article is really great.<br />
There is need of research.</p>
<span class="comments-post">Posted by: <a href="mailto&#58;rashid425&#64;hotmail&#46;com">Rashid Mahmood</a> at May 28, 2003 11:39 PM</span>
</div>
<div class="comments-body">
<p>Hi,</p>

<p>I would have a question concerning the method pointer that is used by the Invoke method of a delegate.</p>

<p>If I understood well, a method pointer is the address of the entry point of the native code of the method, right? When I invoke a delegate, i.e. I call Invoke, then I will start executing the piece of native code that starts at the address that represents the method pointer.</p>

<p>My question is: if I have this address (method pointer), is there a way to know (determine) which method is? Am I able to determine the name of this method, the class that defines it etc (i.e. the complete method reference)?</p>

<p>Many thanks!<br />
George </p>
<span class="comments-post">Posted by: <a href="http://www.inf.ethz.ch/~fruja">George</a> at October  6, 2004 02:51 AM</span>
</div>
<div class="comments-body">
<p>is there any property to inform to the user in online ,that the product he is going to order is finished ,</p>

<p>if there plz mail me </p>
<span class="comments-post">Posted by: <a href="mailto&#58;textindia&#64;yahoo&#46;com">senthil</a> at April  1, 2005 03:53 AM</span>
</div>
<div class="comments-body">
<p>Very nice. I knew, when MSDN said that delegates are "not advised" and the similiarity of the reflection classes, that they are using reflection. It's cheating! anyone can do the same in java. Thanx 4 the article.</p>
<span class="comments-post">Posted by: <a href="mailto&#58;ajifocus&#64;yahoo&#46;com">Ajith</a> at February  8, 2006 11:23 AM</span>
</div>
<div class="comments-body">
<p>Ajith, I don't actually think that delegates use reflection, although both technique do rely on MethodInfo. My understanding is that MethodInfo is the representation of a method pointer in the runtime.<br />
Delegates do have lesser performance than direct function calls, but from the benchmark I've seen they where not that bad.</p>
<span class="comments-post">Posted by: <a href="http://blog.monstuff.com">Julien Couvreur</a> at February  8, 2006 03:09 PM</span>
</div>
<div class="comments-body">
<p>Here is an even darker side to delegates. They are sensitive to the block in which they are declared. Changing the block can change delegate implementation! Here is a stupefying sample, if you change the struct to a class the behaviour reverses (because of stack vs heap):</p>

<p>class ScopeTest<br />
{<br />
 public delegate void aDelegate();<br />
 public struct testStruct //DIFFERENT RESULT with: public class testStruct<br />
 {<br />
  public bool test;<br />
  public testStruct(string nada)<br />
  {<br />
   test = true;<br />
   MakeTestFalse();<br />
   Console.WriteLine(test);<br />
   test = true;<br />
   aDelegate _MakeTestFalse = new aDelegate(MakeTestFalse);<br />
   MakeTestFalseWithDelegate(_MakeTestFalse);<br />
   System.Console.ReadLine();<br />
  }<br />
  public void MakeTestFalse()<br />
  {<br />
   Console.WriteLine("Making test false");<br />
   test = false;<br />
  }<br />
  public void MakeTestFalseWithDelegate(aDelegate adelegate)<br />
  {<br />
   adelegate();<br />
   Console.WriteLine("delegate result: " + test);<br />
  }<br />
 }<br />
 <br />
 public static void Main(string[] args)<br />
 {<br />
  testStruct t = new testStruct("nada");<br />
 }<br />
}</p>
<span class="comments-post">Posted by: <a href="mailto&#58;test&#64;yahoo&#46;com">Brian</a> at February 14, 2006 05:18 AM</span>
</div>
<div class="comments-body">
<p>It's "Instantiate" not "Instanciate"!</p>
<span class="comments-post">Posted by: <a href="mailto&#58;davidcarm&#64;hotmail&#46;com">The Spelling Police</a> at June 23, 2006 02:44 AM</span>
</div>



<div class="comments-head"><a name="trackbacks"></a>Trackbacks</div>



<!-- google_ad_section_end -->

<div class="comments-body">
<!--
Comments are closed. You can <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#117;&#108;&#105;&#101;&#110;&#46;&#99;&#111;&#117;&#118;&#114;&#101;&#117;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">contact me by email</a>. 
-->
</div>


</div>
</div>

<!-- google_ad_section_start(weight=ignore) -->
<div id="links">

<div class="sidetitle">
Recent Entries
</div>

<div class="side">
<a href="/archives.html">All entries (270)</a><br />
<br />

<a href="http://blog.monstuff.com/archives/000380.html">Thick displays</a><br />
<a href="http://blog.monstuff.com/archives/000377.html">Hans Rosling on the facts about population</a><br />
<a href="http://blog.monstuff.com/archives/000376.html">Bill Nye and Ken Ham debating on creationism</a><br />
<a href="http://blog.monstuff.com/archives/000375.html">Prediction vs Explanation</a><br />
<a href="http://blog.monstuff.com/archives/000374.html">Protectionism == Luddism</a><br />
<a href="http://blog.monstuff.com/archives/000373.html">Moderated off Boing Boing</a><br />
<a href="http://blog.monstuff.com/archives/000372.html">I &#9829; Patent Trolls</a><br />
<a href="http://blog.monstuff.com/archives/000371.html">Head Mounted Displays</a><br />
<a href="http://blog.monstuff.com/archives/000370.html">Better async programming in .Net</a><br />
<a href="http://blog.monstuff.com/archives/000369.html">Action, preferences, value</a><br />
<a href="http://blog.monstuff.com/archives/000368.html">Fresh breeze on climate debate</a><br />
<a href="http://blog.monstuff.com/archives/000367.html">On-the-fly book scanning</a><br />
<a href="http://blog.monstuff.com/archives/000366.html">State and education</a><br />
<a href="http://blog.monstuff.com/archives/000365.html">Live Geometry screencast</a><br />
<a href="http://blog.monstuff.com/archives/000364.html">Wired Science TV show</a><br />
<a href="http://blog.monstuff.com/archives/000362.html">Expectations and accountability in Economics</a><br />
<a href="http://blog.monstuff.com/archives/000361.html">Science of human action</a><br />
<a href="http://blog.monstuff.com/archives/000359.html">Reactive programming in javascript and C#</a><br />
<a href="http://blog.monstuff.com/archives/000358.html">Google Wave</a><br />
<a href="http://blog.monstuff.com/archives/000357.html">Reading facial expressions</a><br />

</div>
<!-- google_ad_section_end -->

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>Curiosity is bliss: Modifying IL at runtime</title>

<link rel="stylesheet" href="http://blog.monstuff.com/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.monstuff.com/index.rdf" />

<link rel="start" href="http://blog.monstuff.com/" title="Home" />
<link rel="prev" href="http://blog.monstuff.com/archives/000043.html" title="The efficiency of ternary base" />

<link rel="next" href="http://blog.monstuff.com/archives/000059.html" title="Modifying IL at runtime (step II)" />



<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-74363-1";
urchinTracker();
</script>

<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'blog.monstuff.com';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>



<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="http://blog.monstuff.com/archives/000058.html">
<dc:title>Modifying IL at runtime</dc:title>
<dc:description>If you remember the Omniscient Debugger, it was a Java debugger that instrumented the bytecode at runtime to trace calls and monitor variables. It did so by using a custom ClassLoader. Unfortunately the .NET classes that seemed somewhat equivalent to the Java ClassLoader are sealed, so they can&apos;t be extended. So, for a while I thought runtime instrumentation of the code wasn&apos;t possible in .NET... A couple weeks later, I stumbled onto the NProf (open-source .NET profiler) project and wondered how they did their magic. It turns out they use the CLR Profiling APIs which are COM based and allow...</dc:description>
<dc:creator>Julien</dc:creator>
<dc:date>2003-06-11T21:20:17-08:00</dc:date>
<license rdf:resource="http://creativecommons.org/licenses/by-sa/1.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-sa/1.0/">
<requires rdf:resource="http://web.resource.org/cc/Attribution" />
<requires rdf:resource="http://web.resource.org/cc/Notice" />
<requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
<permits rdf:resource="http://web.resource.org/cc/Reproduction" />
<permits rdf:resource="http://web.resource.org/cc/Distribution" />
<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
</License>
</rdf:RDF>
-->



</head>

<body>

<div id="banner">
<h1><a href="http://blog.monstuff.com/" accesskey="1">Curiosity is bliss</a></h1>
<span class="description">Julien Couvreur's programming blog and more</span>
</div>

<div id="container">

<div class="blog">







<div id="menu">
<a href="http://blog.monstuff.com/archives/000043.html">« The efficiency of ternary base</a>&nbsp;&nbsp; 

| &nbsp;&nbsp;<a href="/archives.html">Archive list</a>&nbsp;&nbsp;
| &nbsp;&nbsp;<a href="http://blog.monstuff.com/archives/000380.html">Thick displays</a> (latest)

</div>

</div>

<div class="blog">

<!-- <h2 class="date">June 11, 2003</h2> -->




<div class="blogbody">
<!-- google_ad_section_start -->

<h2 class="title">Modifying IL at runtime</h2>

<p>If you remember the <a href="http://blog.monstuff.com/archives/000035.html">Omniscient Debugger</a>, it was a Java debugger that instrumented the bytecode at runtime to trace calls and monitor variables. It did so by using a custom ClassLoader.<br />
Unfortunately the .NET classes that seemed somewhat equivalent to the Java ClassLoader are sealed, so they can't be extended. So, for a while I thought runtime instrumentation of the code wasn't possible in .NET...</p>

<p>A couple weeks later, I stumbled onto the <a href="http://nprof.sourceforge.net">NProf</a> (open-source .NET profiler) project and wondered how they did their magic. It turns out they use the CLR Profiling APIs which are COM based and allow you to hook up into various events and get information on the runtime. It is while digging some more into these that I first found a mention of the intriguing <b>ICorProfilerInfo::SetILFunctionBody</b> method.</p>

<p>Although I still think that it is not very well documented (no MSDN reference and very few hits in Google), I have since found bits and pieces of information about this method and wrote a little program that demos its potential.</p>

<p>In this article, we'll go through the steps to build this simple runtime IL transformation program, to give you a better feel of what <i>Get/SetILFunctionBody</i> allows you to do.</p>

<p><u>Update:</u> Follow-up articles are available (<a href="http://blog.monstuff.com/archives/000059.html">step II</a>, <a href="http://blog.monstuff.com/archives/000060.html">step II+</a>, <a href="http://blog.monstuff.com/archives/000077.html">step III</a>).</p>

<a name="more"></a>
<p><b>Background information on the Profiling APIs</b><br />
First you should have a little background on the Profiling APIs of the framework.</p>

<p>The SDK comes with a <i>Tool Developers Guide</i>. It's a directory with various documents, including the precious <i>Profiling.doc</i> file. Since I don't have Word on all my machines, I converted it to pdf and copied it over: <a href="/archives/images/Profiling.pdf">CLR Profiling (Tool Developers Guide)</a>.</p>

<p>Two "Under the Hood" articles on MSDNMag, about the Profiling APIs:<br />
<a href="http://msdn.microsoft.com/msdnmag/issues/01/12/hood/default.aspx">The .NET Profiling API and the DNProfiler Tool</a> and <a href="http://msdn.microsoft.com/msdnmag/issues/01/11/NetProf/default.aspx">NET CLR Profiling Services: Track Your Managed Components to Boost Application Performance</a>.</p>

<p><br />
<b>DNProfiler</b><br />
I used the DNProfiler tool by Matt Pietrek as the foundation for the experiment. You can grab it on the MSDNMag page mentioned above.</p>

<p>You should be able to build DNProfiler with VS.net and run it easily. Try it on a couple simple .NET programs and look at the generated <i>DNProfiler.out</i> file, that contains the output of all <i>ProfilerPrintf</i> calls. You'll see the flood of events that the most simple program can generate.</p>

<p>It turns out that the main event that we'll need is <i>JITCompilationStarted</i>, so you can empty most of the other event methods (leave <i>Initialize</i> as it is, though).</p>

<p>Also, you don't need to receive notification from the CLR for all the events, so you can modify the <i>profiling_on.bat</i> batch to have "set DN_PROFILER_MASK=0x20", where 0x20 means COR_PRF_MONITOR_JIT_COMPILATION. This will tell the CLR to call all the JIT related hook functions in our profiler.</p>

<p><br />
<b>GetILFunctionBody</b><br />
When the foundation is laid and we have a running profiler with a <i>JITCompilationStarted</i> method that gets called, we can start looking at the live IL as it gets JITed.</p>

<p>The <i>ICorProfilerInfo::GetILFunctionBody</i> allows you to do that.</p>

<p>Here is the code I used:<br />
<div class="code">HRESULT CProfilerCallback::JITCompilationStarted(UINT functionId,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;												 BOOL fIsSafeToBlock)<br />
{<br />
&nbsp;	wchar_t wszClass[512];<br />
&nbsp;	wchar_t wszMethod[512];</p>

<p>&nbsp;	// Uncomment the next line to set a breakpoint<br />
&nbsp;	// __asm int 3</p>

<p>&nbsp;	HRESULT hr = S_OK;</p>

<p>&nbsp;	ClassID classId = 0;<br />
&nbsp;	ModuleID moduleId = 0;<br />
&nbsp;	mdToken tkMethod = 0;<br />
&nbsp;	LPCBYTE pMethodHeader = NULL;<br />
&nbsp;	ULONG iMethodSize = 0;</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Get the name of the method that is going to get JITed<br />
&nbsp;	//<br />
&nbsp;	if (GetMethodNameFromFunctionId(functionId, wszClass, wszMethod))<br />
&nbsp;	{<br />
&nbsp;&nbsp;		ProfilerPrintf("JITCompilationStarted: %ls::%ls\n",wszClass,wszMethod);<br />
&nbsp;	} else {<br />
&nbsp;&nbsp;		ProfilerPrintf("JITCompilationStarted\n");<br />
&nbsp;	}</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Get the IL<br />
&nbsp;	//<br />
&nbsp;	hr = m_pICorProfilerInfo->GetFunctionInfo(functionId, &classId, &moduleId, &tkMethod );<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p>&nbsp;	hr = m_pICorProfilerInfo->GetILFunctionBody(moduleId, tkMethod, &pMethodHeader, &iMethodSize);<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Look at the IL and print it out<br />
&nbsp;	//<br />
&nbsp;	IMAGE_COR_ILMETHOD* pMethod = (IMAGE_COR_ILMETHOD*)pMethodHeader;<br />
&nbsp;	COR_ILMETHOD_FAT* fatImage = (COR_ILMETHOD_FAT*)&pMethod->Fat;</p>

<p>&nbsp;	if(!fatImage->IsFat()) {<br />
&nbsp;&nbsp;		COR_ILMETHOD_TINY* tinyImage = (COR_ILMETHOD_TINY*)&pMethod->Tiny;<br />
&nbsp;&nbsp;		//Handle Tiny method<br />
&nbsp;	} else {<br />
&nbsp;&nbsp;		//Handle Fat method<br />
&nbsp;&nbsp;		ProfilerPrintf("Flags: %X\n", fatImage->Flags);<br />
&nbsp;&nbsp;		ProfilerPrintf("Size: %X\n", fatImage->Size);<br />
&nbsp;&nbsp;		ProfilerPrintf("MaxStack: %X\n", fatImage->MaxStack);<br />
&nbsp;&nbsp;		ProfilerPrintf ("CodeSize: %X\n", fatImage->CodeSize);<br />
&nbsp;&nbsp;		ProfilerPrintf("LocalVarSigTok: %X\n", fatImage->LocalVarSigTok);</p>

<p>&nbsp;&nbsp;		byte* codeBytes = fatImage->GetCode();<br />
&nbsp;&nbsp;		ULONG codeSize = fatImage->CodeSize;</p>

<p>&nbsp;&nbsp;		for(ULONG i = 0; i < codeSize; i++) {<br />
&nbsp;&nbsp;&nbsp;			if(codeBytes[i] > 0x0F) {   <br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x%X;\n", i, codeBytes[i]);  <br />
&nbsp;&nbsp;&nbsp;			} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x0%X;\n", i, codeBytes[i]);<br />
&nbsp;&nbsp;&nbsp;			}<br />
&nbsp;&nbsp;		}<br />
&nbsp;	}</p>

<p>exit:<br />
&nbsp;	return hr;<br />
}</div></p>

<p>This code is based on the original DNProfiler method and has code pieces from <a href="http://weblogs.asp.net/jarnold/posts/3347.aspx">this entry</a> and <a href="http://weblogs.asp.net/JArnold/posts/4170.aspx">this entry</a> from Jimski's blog.</p>

<p>You'll need to <i>#include "corhlpr.h"</i> to get access to the type definitions like COR_ILMETHOD_FAT.</p>

<p>The sample Hello.cs file (compiled with "csc Hello.cs"):<br />
<div class="code">using System;</p>

<p>public class Hello <br />
{<br />
&nbsp;	public static void Main(string[] prms) <br />
&nbsp;	{<br />
&nbsp;&nbsp;		Console.WriteLine("hello world!");<br />
&nbsp;&nbsp;		Console.WriteLine("test!");<br />
&nbsp;	}<br />
}</div></p>

<p><br />
This brings the following DNProfiler.out file:<br />
<div class="code">Initialize<br />
JITCompilationStarted: Hello::Main<br />
Flags: 13<br />
Size: 3<br />
MaxStack: 1<br />
CodeSize: 15<br />
LocalVarSigTok: 0<br />
codeBytes[0] = 0x72;<br />
codeBytes[1] = 0x01;<br />
codeBytes[2] = 0x00;<br />
codeBytes[3] = 0x00;<br />
codeBytes[4] = 0x70;<br />
codeBytes[5] = 0x28;<br />
codeBytes[6] = 0x02;<br />
codeBytes[7] = 0x00;<br />
codeBytes[8] = 0x00;<br />
codeBytes[9] = 0x0A;<br />
codeBytes[10] = 0x72;<br />
codeBytes[11] = 0x1B;<br />
codeBytes[12] = 0x00;<br />
codeBytes[13] = 0x00;<br />
codeBytes[14] = 0x70;<br />
codeBytes[15] = 0x28;<br />
codeBytes[16] = 0x02;<br />
codeBytes[17] = 0x00;<br />
codeBytes[18] = 0x00;<br />
codeBytes[19] = 0x0A;<br />
codeBytes[20] = 0x2A;<br />
Shutdown</div></p>

<p><br />
If you run "ildasm /bytes Hello.exe", you'll see the matching bytes in the dis-assembled version of the <i>Main</i> method. ILdasm will give you more insight on what the bytes actually mean and how they are grouped.<br />
The comparison of the output and the ILdasm dis-assembly suggests that switching codeBytes[1]  and codeBytes[11] could lead to printing the strings in the reverse order. That's what we'll try and do :-)</p>

<p><br />
<b>SetILFunctionBody</b><br />
Here is the code I used to switch the two string prints in Hello.exe:<br />
<div class="code">HRESULT CProfilerCallback::JITCompilationStarted(UINT functionId,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;												 BOOL fIsSafeToBlock)<br />
{<br />
&nbsp;	wchar_t wszClass[512];<br />
&nbsp;	wchar_t wszMethod[512];</p>

<p>&nbsp;	//__asm int 3<br />
&nbsp;	HRESULT hr = S_OK;</p>

<p>&nbsp;	ClassID classId = 0;<br />
&nbsp;	ModuleID moduleId = 0;<br />
&nbsp;	mdToken tkMethod = 0;<br />
&nbsp;	LPCBYTE pMethodHeader = NULL;<br />
&nbsp;	ULONG iMethodSize = 0;</p>

<p>&nbsp;	if ( GetMethodNameFromFunctionId( functionId, wszClass, wszMethod ) )<br />
&nbsp;	{<br />
&nbsp;&nbsp;		ProfilerPrintf("JITCompilationStarted: %ls::%ls\n",wszClass,wszMethod);<br />
&nbsp;	} else {<br />
&nbsp;&nbsp;		ProfilerPrintf( "JITCompilationStarted\n" );<br />
&nbsp;&nbsp;		goto exit;<br />
&nbsp;	}<br />
&nbsp;	if (wcscmp(wszClass, L"Hello") != 0 || wcscmp(wszMethod, L"Main") != 0) {<br />
&nbsp;&nbsp;		goto exit;<br />
&nbsp;	}</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Get the existing IL<br />
&nbsp;	//<br />
&nbsp;	hr = m_pICorProfilerInfo->GetFunctionInfo(functionId, &classId, &moduleId, &tkMethod );<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p>&nbsp;	hr = m_pICorProfilerInfo->GetILFunctionBody(moduleId, tkMethod, &pMethodHeader, &iMethodSize);<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Print the existing IL<br />
&nbsp;	//<br />
&nbsp;	IMAGE_COR_ILMETHOD* pMethod = (IMAGE_COR_ILMETHOD*)pMethodHeader;<br />
&nbsp;	COR_ILMETHOD_FAT* fatImage = (COR_ILMETHOD_FAT*)&pMethod->Fat;</p>

<p>&nbsp;	if(!fatImage->IsFat()) {<br />
&nbsp;&nbsp;		COR_ILMETHOD_TINY* tinyImage = (COR_ILMETHOD_TINY*)&pMethod->Tiny;<br />
&nbsp;&nbsp;		//Handle Tiny method<br />
&nbsp;	} else {<br />
&nbsp;&nbsp;		//Handle Fat method<br />
&nbsp;&nbsp;		ProfilerPrintf("Flags: %X\n", fatImage->Flags);<br />
&nbsp;&nbsp;		ProfilerPrintf("Size: %X\n", fatImage->Size);<br />
&nbsp;&nbsp;		ProfilerPrintf("MaxStack: %X\n", fatImage->MaxStack);<br />
&nbsp;&nbsp;		ProfilerPrintf ("CodeSize: %X\n", fatImage->CodeSize);<br />
&nbsp;&nbsp;		ProfilerPrintf("LocalVarSigTok: %X\n", fatImage->LocalVarSigTok);</p>

<p>&nbsp;&nbsp;		byte* codeBytes = fatImage->GetCode();<br />
&nbsp;&nbsp;		ULONG codeSize = fatImage->CodeSize;</p>

<p>&nbsp;&nbsp;		for(ULONG i = 0; i < codeSize; i++) {<br />
&nbsp;&nbsp;&nbsp;			if(codeBytes[i] > 0x0F) {   <br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x%X;\n", i, codeBytes[i]);  <br />
&nbsp;&nbsp;&nbsp;			} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x0%X;\n", i, codeBytes[i]);<br />
&nbsp;&nbsp;&nbsp;			}<br />
&nbsp;&nbsp;		}<br />
&nbsp;	}</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Get the IL Allocator<br />
&nbsp;	//<br />
&nbsp;	IMethodMalloc* pIMethodMalloc = NULL;<br />
&nbsp;	IMAGE_COR_ILMETHOD* pNewMethod = NULL;<br />
&nbsp;	hr = m_pICorProfilerInfo->GetILFunctionBodyAllocator(moduleId, &pIMethodMalloc);<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Allocate IL space and copy the IL in it<br />
&nbsp;	//<br />
&nbsp;	pNewMethod = (IMAGE_COR_ILMETHOD*) pIMethodMalloc->Alloc(iMethodSize);<br />
&nbsp;	if (pNewMethod == NULL)<br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p>&nbsp;	memcpy((void*)pNewMethod, (void*)pMethod, iMethodSize);</p>

<p><br />
&nbsp;	//<br />
&nbsp;	// Print IL copy, modify it and print it again<br />
&nbsp;	//<br />
&nbsp;	COR_ILMETHOD_FAT* newFatImage = (COR_ILMETHOD_FAT*)&pNewMethod->Fat;<br />
&nbsp;	if(!newFatImage->IsFat()) {<br />
&nbsp;&nbsp;		COR_ILMETHOD_TINY* newTinyImage = (COR_ILMETHOD_TINY*)&pNewMethod->Tiny;<br />
&nbsp;&nbsp;		//Handle Tiny method<br />
&nbsp;	} else {<br />
&nbsp;&nbsp;		//Handle Fat method<br />
&nbsp;&nbsp;		ProfilerPrintf("New Flags: %X\n", newFatImage->Flags);<br />
&nbsp;&nbsp;		ProfilerPrintf("New Size: %X\n", newFatImage->Size);<br />
&nbsp;&nbsp;		ProfilerPrintf("New MaxStack: %X\n", newFatImage->MaxStack);<br />
&nbsp;&nbsp;		ProfilerPrintf ("New CodeSize: %X\n", newFatImage->CodeSize);<br />
&nbsp;&nbsp;		ProfilerPrintf("New LocalVarSigTok: %X\n", newFatImage->LocalVarSigTok);</p>

<p>&nbsp;&nbsp;		byte* codeBytes = newFatImage->GetCode();<br />
&nbsp;&nbsp;		ULONG codeSize = newFatImage->CodeSize;</p>

<p>&nbsp;&nbsp;		for(ULONG i = 0; i < codeSize; i++) {<br />
&nbsp;&nbsp;&nbsp;			if(codeBytes[i] > 0x0F) {   <br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x%X;\n", i, codeBytes[i]);  <br />
&nbsp;&nbsp;&nbsp;			} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x0%X;\n", i, codeBytes[i]);<br />
&nbsp;&nbsp;&nbsp;			}<br />
&nbsp;&nbsp;		}</p>

<p><br />
&nbsp;&nbsp;		//<br />
&nbsp;&nbsp;		// Tweak the IL (switch the bytes)<br />
&nbsp;&nbsp;		//<br />
&nbsp;&nbsp;		BYTE temp;<br />
&nbsp;&nbsp;		temp = codeBytes[1];<br />
&nbsp;&nbsp;		codeBytes[1] = codeBytes[11];<br />
&nbsp;&nbsp;		codeBytes[11] = temp;</p>

<p><br />
&nbsp;&nbsp;		//<br />
&nbsp;&nbsp;		// Print the modified IL<br />
&nbsp;&nbsp;		//<br />
&nbsp;&nbsp;		for(ULONG i = 0; i < codeSize; i++) {<br />
&nbsp;&nbsp;&nbsp;			if(codeBytes[i] > 0x0F) {   <br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x%X;\n", i, codeBytes[i]);  <br />
&nbsp;&nbsp;&nbsp;			} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;				ProfilerPrintf("codeBytes[%u] = 0x0%X;\n", i, codeBytes[i]);<br />
&nbsp;&nbsp;&nbsp;			}<br />
&nbsp;&nbsp;		}<br />
&nbsp;	}</p>

<p><br />
&nbsp;	hr = m_pICorProfilerInfo->SetILFunctionBody(moduleId, tkMethod, (LPCBYTE) pNewMethod);<br />
&nbsp;	if (FAILED(hr)) <br />
&nbsp;&nbsp;		{ goto exit; }</p>

<p><br />
&nbsp;	pIMethodMalloc->Release();</p>

<p>exit:<br />
&nbsp;	return hr;<br />
}</div></p>

<p>If you run Hello.exe with this profiler, you'll get "Test!" then "Hello World!", which confirms that the IL was modified. Success !!<br />
You'll notice that it is completely hardcoded for the current Hello.exe example, so you shouldn't try it on other assemblies.</p>

<p>If you try to tweak the IL that you got out of <i>GetILFunctionBody</i>, you'll get an access violation because it is read-only. This is why we first make a copy of it, then tweak it and finally set it back in with <i>SetILFunctionBody</i>.</p>

<p><br />
<b>To infinity and beyond</b><br />
So far, only a very simple assembly got runtime-modified.<br />
But I hope this helped you realize how powerful this technique can be. For example, <a href="http://iunknown.com/">John Lam</a> appears to be implementing an AOP extension to the CLR using these Profiling APIs.<br />
A better understanding of the IL is needed in order to do more powerful modifications: calling other methods (in the current class or on a reference), adding runtime safety checks (for contract programming), monitoring methods and properties that bear a certain attribute.</p>

<p>Let me know of your experiments in the area,<br />
Have fun,<br />
Dumky</p>

<p><b>Other references</b><br />
<a href="http://dotnet.di.unipi.it/Content/sscli/docs/doxygen/clr/vm/corhlpr_8h-source.html#l00462">COR_ILMETHOD and other declarations from the Rotor source code</a>.<br />
<a href="http://www.mail-archive.com/dotnet-rotor@discuss.develop.com/msg00510.html">Another Get/SetILFunctionBody sample</a>.<br />
A set of slides on <a href="http://www.iunknown.com/Files/CLAW_Implementation.ppt">CLAW and the Profiler APIs</a>.</p>

<span class="posted">Posted by Julien on June 11, 2003. <a href="http://blog.monstuff.com/archives/000058.html" rel="bookmark">Permalink</a> <!-- -->
<br /></span>

</div>



<div class="comments-head"><a name="comments"></a>Comments</div>

<div class="comments-body">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'curiosityisbliss'; 
        var disqus_identifier = '58';
        var disqus_url = 'http://blog.monstuff.com/archives/000058.html';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>    





<div class="comments-body">
<p>Good to see another profiling adventurer out there!  I haven't written up anything more in my blog due to lack of time, but I got to the stage where I was inserting/replacing bytecode to call other methods.  I started using the debugger API to get at local values on the stack, but then I got a job :-)</p>

<p>Keep it up though, I'd be interested in how you get on.</p>

<p>Jim</p>
<span class="comments-post">Posted by: <a href="http://weblogs.asp.net/jarnold">Jim Arnold</a> at June 13, 2003 06:42 AM</span>
</div>
<div class="comments-body">
<p>Thanks for your comment. It really is an adventure. I'm hoping to make it a bit easier for the future adventurers though ;-)</p>

<p>Yesterday night, I managed to insert an extra function call in the Main method. The function that is called is a static method from the same class, and I still have the method's token hardcoded.</p>

<p>To get ride of this hardcoding, I started doing some metadata inspection and so far got to list the methods' names and tokens. <br />
I'll post this code soon (after the week-end).</p>

<p>The next step is to inspect the signature. Then add a method call to another class. Then add monitoring to property and variable access. Then ... (who knows ;-)</p>

<p>Cheers<br />
Dumky</p>
<span class="comments-post">Posted by: <a href="http://blog.monstuff.com">Dumky</a> at June 13, 2003 02:31 PM</span>
</div>
<div class="comments-body">
<p><a href="http://www.clrinternals.com/TraceHook.htm">http://www.clrinternals.com/TraceHook.htm</a> is a tracing solution based on ContextBoundObject. It has some important limitations, but still is quite interesting.</p>
<span class="comments-post">Posted by: <a href="http://blog.monstuff.com">Dumky</a> at July 17, 2003 10:31 PM</span>
</div>
<div class="comments-body">
<p>Hi,<br />
  your articles about this thema are very interesting. I found them, when I was looking for some information about lazy collection initialization. I created some library for object persistence in database. When I load objects with child collections, I want to initialize them at the time when the collections are needed (not when loading).<br />
  Problem is that I am not able to catch the moment when the object is needed. So I want to rename the variable of the collection and create some getter/setter in runtime. The property will have the name that the collection had before renaming and will ensure the collection initialization (via some branching and my library). And all this should be done in runtime.<br />
  I know that this is something different from profiling, but I think there are some similarities and I thank for every information.<br />
  Thanks <br />
              Karel Frajtak</p>
<span class="comments-post">Posted by: <a href="mailto&#58;kfrajtak&#64;lekis&#46;cz">Karel Frajtak</a> at August  8, 2003 12:12 AM</span>
</div>
<div class="comments-body">
<p>I forgot: I am implementing it in C#.</p>
<span class="comments-post">Posted by: <a href="mailto&#58;kfrajtak&#64;lekis&#46;cz">Karel Frajtak</a> at August  8, 2003 12:33 AM</span>
</div>



<div class="comments-head"><a name="trackbacks"></a>Trackbacks</div>

<div class="trackback-body">
<a name="41"></a>
<span class="trackback-post"><a href="http://www.cnblogs.com/dudu/archive/2004/05/19/10255.aspx" target="new">IL modification at runtime (step III)</a><br />
<b>Excerpt:</b> IL modification at runtime (step III)<br />
<b>Weblog:</b> dudu<br />
<b>Tracked:</b> May 18, 2004 10:28 PM</span>
</div>
<div class="trackback-body">
<a name="43"></a>
<span class="trackback-post"><a href="http://www.cnblogs.com/dudu/archive/2004/05/23/11013.aspx" target="new">The dark side of C# Delegates</a><br />
<b>Excerpt:</b> The dark side of C# Delegates<br />
<b>Weblog:</b> dudu<br />
<b>Tracked:</b> May 23, 2004 04:00 AM</span>
</div>


<!-- google_ad_section_end -->

<div class="comments-body">
<!--
Comments are closed. You can <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#117;&#108;&#105;&#101;&#110;&#46;&#99;&#111;&#117;&#118;&#114;&#101;&#117;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">contact me by email</a>. 
-->
</div>


</div>
</div>

<!-- google_ad_section_start(weight=ignore) -->
<div id="links">

<div class="sidetitle">
Recent Entries
</div>

<div class="side">
<a href="/archives.html">All entries (270)</a><br />
<br />

<a href="http://blog.monstuff.com/archives/000380.html">Thick displays</a><br />
<a href="http://blog.monstuff.com/archives/000377.html">Hans Rosling on the facts about population</a><br />
<a href="http://blog.monstuff.com/archives/000376.html">Bill Nye and Ken Ham debating on creationism</a><br />
<a href="http://blog.monstuff.com/archives/000375.html">Prediction vs Explanation</a><br />
<a href="http://blog.monstuff.com/archives/000374.html">Protectionism == Luddism</a><br />
<a href="http://blog.monstuff.com/archives/000373.html">Moderated off Boing Boing</a><br />
<a href="http://blog.monstuff.com/archives/000372.html">I &#9829; Patent Trolls</a><br />
<a href="http://blog.monstuff.com/archives/000371.html">Head Mounted Displays</a><br />
<a href="http://blog.monstuff.com/archives/000370.html">Better async programming in .Net</a><br />
<a href="http://blog.monstuff.com/archives/000369.html">Action, preferences, value</a><br />
<a href="http://blog.monstuff.com/archives/000368.html">Fresh breeze on climate debate</a><br />
<a href="http://blog.monstuff.com/archives/000367.html">On-the-fly book scanning</a><br />
<a href="http://blog.monstuff.com/archives/000366.html">State and education</a><br />
<a href="http://blog.monstuff.com/archives/000365.html">Live Geometry screencast</a><br />
<a href="http://blog.monstuff.com/archives/000364.html">Wired Science TV show</a><br />
<a href="http://blog.monstuff.com/archives/000362.html">Expectations and accountability in Economics</a><br />
<a href="http://blog.monstuff.com/archives/000361.html">Science of human action</a><br />
<a href="http://blog.monstuff.com/archives/000359.html">Reactive programming in javascript and C#</a><br />
<a href="http://blog.monstuff.com/archives/000358.html">Google Wave</a><br />
<a href="http://blog.monstuff.com/archives/000357.html">Reading facial expressions</a><br />

</div>
<!-- google_ad_section_end -->

</body>
</html>

---
title: "Unittesting asynchronous methods"
date: 2007-08-31 10:00:46 +0800
disqus_identifier: 323
disqus_url: http://blog.monstuff.com/archives/000323.html
---
{% raw %}
<p><a href="http://www.flickr.com/photos/11431505@N00/1279665755/" border="0"><img src="http://farm2.static.flickr.com/1316/1279665755_a5a7cc64e4_m.jpg" alt="Boomerang catch" style="float: right; padding: 10px 0px 0px 20px; width:93; height:100; border: none" /></a></p>

<p>How to unittest asynchronous methods in .Net?  </p>

<p>If you have encountered this situation, you probably wrote yourself a test harness which understands the asynchronous callback and can wait on either the callback(s) or a timeout.<br />
But like mock objects, writing such helpers objects quickly becomes tedious. <br />
 <br />
 <br />
I found a generic solution to avoid most of this repetitive code. The CallbackWaiter class generates your test harness, just like mock frameworks. <br />
You can <a href="http://jcouv.googlecode.com/svn/trunk/CallbackWaiter/src/">browse the CallbackWaiter code</a> or get the <a href="http://code.google.com/p/jcouv/wiki/CallbackWaiter">full project</a> (including unittests and VS project files).</p>

<p>This solution works for any .Net language. The same approach can easily be implemented in Javascript and probably any dynamic language. I'm not sure about Java though (does it support runtime-defined methods?).</p>
<p> <br />
<h4>Setting a goal:</h4> I started by imagining what my ideal unittest would look like, using the "magical thinking" approach:<br />
<div class="code">    [Test]<br />
    public void TestAsyncMethod()<br />
    {<br />
&nbsp;&nbsp;        MyAsyncService service = new MyAsyncService();</p>

<p>&nbsp;&nbsp;        EventHandler<MyEventArgs> magicHandler = <br />
&nbsp;&nbsp;&nbsp;&nbsp;            new MagicHandler<MyEventArgs>();</p>

<p>&nbsp;&nbsp;        service.CallbackEvent += magicHandler;<br />
&nbsp;&nbsp;        service.DoAsyncWork(3); // Start the asynchronous work. Doesn't block.</p>

<p>&nbsp;&nbsp;        int timeout = 1000;<br />
&nbsp;&nbsp;        MyEventArgs returnValue = magicHandler.Wait(timeout); // Wait for either the event or a timeout</p>

<p>&nbsp;&nbsp;        Assert.AreEqual(3, returnValue.result); // Get the information channeled by the event.<br />
    }</div></p>

<p>The trouble is implementing the "MagicHandler" ;-)</p>

<p><h4>RealProxy, a dead-end:</h4> To implement the MagicHandler, I first looked at the <a href="http://msdn2.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy.aspx">RealProxy class</a>, since it is used by nMock to write generic objects. <br />
RealProxy has the ability to camouflage as a different type (see the <a href="http://msdn2.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy.gettransparentproxy.aspx">RealProxy.GetTransparentProxy</a> method), intercept any calls that it receives and funnel them through a generic <a href="http://msdn2.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy.invoke.aspx">IMessage Invoke(IMessage myIMessage)</a> method that you have to implement.</p>

<p>But it turns out that it RealProxy can only emulate MarshalByRef objects. That unfortunately does not work to write a generic delegate, since the Delegate base class is not a MarshalByRef object.</p>

<p><h4>A working solution:</h4> Another approach that looked promising is using the <a href="http://msdn2.microsoft.com/en-us/library/exczf7b9.aspx">DynamicMethod</a> API, introduced in .Net 2.0, which allows to emit methods at runtime.</p>

<p>After running into the <a href="http://geekswithblogs.net/kraki/archive/2006/03/29/73743.aspx">same issues</a> as Rich McColllister and Mike Woodring, including the weird <a href="http://msdn2.microsoft.com/en-us/library/56b2hk61(VS.80).aspx">CS0702 error</a>, I ended-up using the same workarounds.</p>

<p>After validating that it is possible to generate dynamic methods and hook them to the generic class, I ironed out some smaller issues: match target signature, record event parameters, support value type parameters (code crashes without a boxing IL instruction), make the class thread safe and support multiple callbacks.</p>

<p><h4>Some tricks learned:</h4> <ul><li>When you write code that needs to emit IL, you should write examples of the desired code in C#, compile it and look at the IL generated by the compiler (using <a href="http://msdn2.microsoft.com/en-us/library/f7dy01k1(VS.71).aspx">ildasm</a>) as an example. </li><li>When working with DynamicMethods, Haibo Luo's <a href="http://blogs.msdn.com/haibo_luo/archive/2006/11/16/take-two-il-visualizer.aspx">IL visualizer</a> is a useful VS.Net extension which let's you conveniently peek at the IL composing DynamicMethod objects. </li><li>If you generate bad IL, the CLR may throw an exception (InvalidProgramException) or crash. Both cases are hard to troubleshoot, as you get very little information as to what caused it (I wish the InvalidProgramException would tell you what is invalid about your program...). I would again recommend to compare your IL with some generated by the C# compiler. </li></ul></p>

<p><h4>Update (2008/12/25):</h4> The Concurrency and Coordination Runtime (CCR) which started as a domain-specific toolkit (for robotics) is being opened up for general purpose. It allows you to deal with asynchrony very cleanly in your code, just like I was trying to achieve with the CallbackWaiter: the code that executes after the asynchronous call is in the same method that started it (no need for large delegates or separate methods). <br />
But CallbackWaiter is obviously very specialized as it only deals with a single async call and has built-in logic for timeout. The CCR allows you to do that and much more.<br />
Learn more with the <a href="http://channel9.msdn.com/pdc2008/TL55/">PDC2008 CCR presentation (video)</a> (the interesting part starts at 9:35).<br />
</p>



{% endraw %}
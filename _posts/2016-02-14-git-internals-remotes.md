---
published: false
title: "Git Internals - Remotes"
---

My previous article on [Git Internals](http://blog.monstuff.com/archives/2015/08/git-internals.html) described the object model for a single repository. But how do distributed repositories work together?  
As I'll try to explain, I think the key is immutability.  
 
## Graph of commits
The core design of Git revolves around building a graph of commits where each commit points to parent commits and to a tree of objects (representing files and folders). Commits and tree objects are immutable; they are only added, never modified.  
This immutability (and the fact that all those objects have globally unique content-based identifiers) make it safe for people to party on this graph across the world. Each contributor is just adding new commits to the graph, each with a new object tree. The new commits can reference existing commits and the new object trees can reference existing tree objects. All those new objects could then be safely shared to others without conflicts.  

## References
Not everything in Git is immutable though. Branch references, which are also simply called branches, are updateable references to commits.   
They key to avoiding distributed conflicts is clear ownership: a repository can only modify branches it owns, and receive updates for other branches from their owners.  
Branches are namespaced, so you can tell which ones each remote repository owns and which ones your local instance owns. If your repository is linked to "remote1" and "remote2", their branches will be named "remote1/blah" and "remote2/foo", while your local branches will simply be named "bar". 
 
## Fetch, merge, rebase and push
Fetch transfers branches from the remote repository and all the objects necessary to complete their history.  
This does not update your own repository's branches, and therefore is conflict-free.  
  
On the other hand, merge and rebase will update one of your repository's own branches. Both merge and rebase are designed to handle divergence: the remote branch added some commits and your local branch added some other commits.  

Merge will create a new commit with two parents: the commit referenced by the remote branch and the one referenced by your local branch. It is generated by considering all changes since their common commit ancestor, and may require manual intervention to resolve conflicts. Your local branch is updated to reference this commit after it is created.   
The degenerate case where the your branch had no changes (and points to the common ancestor) is simpler: your local branch will be updated to match the remote branch, without need to make a new commit. It is called fast-forward.  
As a side note, the Git pull operation combines a fetch and a merge.  

Rebase will create a chain of new commits which descend from the commit referenced by the remote branch and update your branch to reference the last commit in the new chain. Those new commits replay the changes you had in your local branch (since the common ancestor commit). The chain that is generated can be tweaked during rebase, for instance to combine or split the original commits.  

Merge and rebase are not only useful when your local branch and its corresponding remote branch have had new commits, but in any situation that involves two branches.  
Both merge and rebase will leave one of the branch references intact and only update the other one (the reference for the working branch).  
  
Push is just a remote merge. You tell the remote repository about some new commits of yours and you asking it to update one of its own branch references.  

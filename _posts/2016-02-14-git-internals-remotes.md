---
published: false
title: "Git Internals - Remotes"
---

My previous article on [Git Internals](http://blog.monstuff.com/archives/2015/08/git-internals.html) described the object model for a single repository. But how do distributed repositories work together?  
As I'll try to explain, I think the key is immutability.  
 
## Graph of commits
The core design of Git revolves around building a graph of commits where each commit points to parent commits and to a tree of objects (representing files and folders). Commits and tree objects are immutable; they are only added, never modified.  
This immutability (and the fact that all those objects have globally unique content-based identifiers) make it safe for people to party on this graph across the world. Each contributor is just adding new commits to the graph, each with a new object tree. The new commits can reference existing commits and the new object trees can reference existing tree objects. All those new objects could then be safely shared to others without conflicts.  

## References
Not everything in Git is immutable though. Branch references, which are also simply called branches, are updateable references to commits.   
They key to avoiding distributed conflicts is clear ownership: a repository can only modify branches it owns, and receive updates for other branches from their owners.  
Branch names are namespaced, so you can tell which ones each remote repository owns and which ones your local instance owns. If your repository is linked to "remote1" and "remote2", their branches will be named "remote1/blah" and "remote2/foo", while your local branches will simply be named "bar". 
 
## Fetch, merge, rebase, push and pull
We'll now look at some operations and how they affect the commit graph and the branch references.  

**Fetch** get updates from a remote repository. You will get updated branch references and all the objects necessary to complete their history.  
This does not update your own repository's branches and therefore is conflict-free.  
  
On the other hand, merge and rebase will update one of your repository's own branches. Both merge and rebase are designed to handle divergence: the remote branch added some commits and your local branch added some other commits.  

**Merge** will create a new commit with two parents: the commit referenced by the remote branch and the one referenced by your local branch. It is generated by considering all changes since their common commit ancestor, and may require manual intervention to resolve conflicts. Your local branch is updated to reference this commit after it is created.   
The degenerate case where the your branch had no changes (and points to the common ancestor) is simpler: your local branch will be updated to match the remote branch, without need to make a new commit. It is called fast-forward.  

As a side note, a **pull** operation combines a fetch and a merge.  


**Rebase** will create a chain of new commits which descend from the commit referenced by the remote branch and then update your branch to reference the last commit in that new chain.  
Those new commits replay the changes you had in your local branch (since the common ancestor commit). The chain that is generated could be interactively tweaked during rebase, for instance to combine or split the original commits in some way.  


Merge and rebase are not only useful when your local branch and its corresponding remote branch have had new commits, but in situations that involves two local branches.  
Both merge and rebase will leave one of the branch references intact and only update the other one (the working branch).  
  
**Push** is just a remote merge. You tell the remote repository about some new commits of yours and you asking it to update one of its own branch references.  

## Example
Lets look at an example using illustrations borrowed from [Pro Git](http://git-scm.com/book/en/v2).
The first one shows two branches that diverged, by adding one commit each.
![git-divergence.png]({{site.baseurl}}/archives/images/git-divergence.png)

Merging is one way to handle this divergence. It adds a new commit (`C5`) which has two parents and updates one of the branch references (`master` in this instance).
![git-merged-divergence.png]({{site.baseurl}}/archives/images/git-merged-divergence.png)

Another way to handle this same situation is to use rebase. It adds a new chain of commits (only one in this example, `C4'`) to one side. Those new commits replay the changes on the other side of the divergence (`C4`) since the common ancestor (`C2`). Then it updates the other branch reference (`experiment` in this example).
![git-rebased-divergence.png]({{site.baseurl}}/archives/images/git-rebased-divergence.png)

After this rebase, if we try to update the `master` branch with a merge of the `experiment` branch, this will be a fast-forward merge. It simply updates the `master` reference and does not require creating a two-parent commit.  
![git-fast-forward.png]({{site.baseurl}}/archives/images/git-fast-forward.png)

This example used two local branch names, but the operations work exactly the same with one remote branch, which is read-only to you, and one local branch, which will be updated.

## Summary
To recap, there are a few principles that illuminate Git's design:
1) The commit graph and the object trees are immutable
2) Commits and objects are referenced by globally unique identifiers
3) Branches are mutable but are namespaced and have clear ownership rules

PS: 